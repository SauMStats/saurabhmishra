// @ts-ignore - Virtual module generated by Vite plugin
import { markdownPosts } from 'virtual:blog-content';

export interface BlogPost {
  id: string;
  title: string;
  slug: string;
  excerpt: string;
  content: string;
  publishedAt: string;
  readTime: string;
  tags?: string[];
  featured?: boolean;
  author?: string;
  series?: string;
  seriesOrder?: number;
  seriesTitle?: string;
  pdf?: string;
  pdfs?: Array<{ title: string; filename: string; path?: string }>;
  _filePath?: string;
  _assetsPath?: string;
}

export interface SeriesInfo {
  name: string;
  title: string;
  description?: string;
  posts: BlogPost[];
  totalPosts: number;
  totalReadTime: number;
}

/**
 * Get all blog posts (both hardcoded and markdown-based)
 */
export function getAllBlogPosts(): BlogPost[] {
  // In the future, you can merge with hardcoded posts if needed
  // return [...hardcodedPosts, ...markdownPosts];
  return markdownPosts || [];
}

/**
 * Get a single blog post by slug
 */
export function getBlogPost(slug: string): BlogPost | undefined {
  const posts = getAllBlogPosts();
  return posts.find(post => post.slug === slug);
}

/**
 * Get all posts in a specific series, sorted by seriesOrder
 */
export function getSeriesPosts(seriesName: string): BlogPost[] {
  const posts = getAllBlogPosts();
  return posts
    .filter(post => post.series === seriesName)
    .sort((a, b) => (a.seriesOrder || 0) - (b.seriesOrder || 0));
}

/**
 * Get series information including all posts
 */
export function getSeriesInfo(seriesName: string): SeriesInfo | undefined {
  const posts = getSeriesPosts(seriesName);
  
  if (posts.length === 0) {
    return undefined;
  }
  
  // Extract series title from first post or use series name
  const seriesTitle = posts[0].seriesTitle || formatSeriesName(seriesName);
  
  // Calculate total reading time
  const totalReadTime = posts.reduce((total, post) => {
    const minutes = parseInt(post.readTime) || 0;
    return total + minutes;
  }, 0);
  
  return {
    name: seriesName,
    title: seriesTitle,
    description: posts[0].excerpt, // Use first post's excerpt as series description
    posts,
    totalPosts: posts.length,
    totalReadTime
  };
}

/**
 * Get all unique series
 */
export function getAllSeries(): SeriesInfo[] {
  const posts = getAllBlogPosts();
  const seriesMap = new Map<string, BlogPost[]>();
  
  // Group posts by series
  posts.forEach(post => {
    if (post.series) {
      if (!seriesMap.has(post.series)) {
        seriesMap.set(post.series, []);
      }
      seriesMap.get(post.series)!.push(post);
    }
  });
  
  // Convert to SeriesInfo array
  const series: SeriesInfo[] = [];
  seriesMap.forEach((posts, seriesName) => {
    const info = getSeriesInfo(seriesName);
    if (info) {
      series.push(info);
    }
  });
  
  return series;
}

/**
 * Get navigation info for a post in a series
 */
export function getSeriesNavigation(post: BlogPost): {
  previous: BlogPost | null;
  next: BlogPost | null;
  current: number;
  total: number;
} | null {
  if (!post.series || post.seriesOrder === undefined) {
    return null;
  }
  
  const seriesPosts = getSeriesPosts(post.series);
  const currentIndex = seriesPosts.findIndex(p => p.slug === post.slug);
  
  if (currentIndex === -1) {
    return null;
  }
  
  return {
    previous: currentIndex > 0 ? seriesPosts[currentIndex - 1] : null,
    next: currentIndex < seriesPosts.length - 1 ? seriesPosts[currentIndex + 1] : null,
    current: currentIndex + 1,
    total: seriesPosts.length
  };
}

/**
 * Get posts by tag
 */
export function getBlogPostsByTag(tag: string): BlogPost[] {
  const posts = getAllBlogPosts();
  return posts.filter(post => post.tags?.includes(tag));
}

/**
 * Get all featured posts
 */
export function getFeaturedPosts(): BlogPost[] {
  const posts = getAllBlogPosts();
  return posts.filter(post => post.featured);
}

/**
 * Get all unique tags
 */
export function getAllTags(): string[] {
  const posts = getAllBlogPosts();
  const tagSet = new Set<string>();
  
  posts.forEach(post => {
    post.tags?.forEach(tag => tagSet.add(tag));
  });
  
  return Array.from(tagSet).sort();
}

/**
 * Get standalone posts (not part of any series)
 */
export function getStandalonePosts(): BlogPost[] {
  const posts = getAllBlogPosts();
  return posts.filter(post => !post.series);
}

/**
 * Format series name for display
 */
function formatSeriesName(seriesName: string): string {
  return seriesName
    .split('-')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
}

/**
 * Search posts by title, excerpt, or content
 */
export function searchPosts(query: string): BlogPost[] {
  const posts = getAllBlogPosts();
  const lowerQuery = query.toLowerCase();
  
  return posts.filter(post =>
    post.title.toLowerCase().includes(lowerQuery) ||
    post.excerpt.toLowerCase().includes(lowerQuery) ||
    post.content.toLowerCase().includes(lowerQuery) ||
    post.tags?.some(tag => tag.toLowerCase().includes(lowerQuery))
  );
}
